---
title: "adace example"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(adace)
```

## Setup

The adace R package can be installed directly from CRAN using install.packages("adace") and then loaded into the the environment using library(adace). The package does have some dependencies, including reshape2, parcma, cuature, and MASS. It is recommended to install these packages if asked when installing adace.


## Functions in adace

There are 4 user functions in the package. Each of the functions calculate the adherers average causal estimate for a specified method and population. For example the function *est_S_Plus_Plus_MethodA* calculates the adherers estimator for Method A using population S++, the patients that can adhere to both treatment and control. Additional internal package functions are also listed in the package documentation and are utility functions called inside the user functions.

All user functions contain the same set of arguments. The arguments are the following:

1. **X**: Matrix of baseline covariates
2. **A**: Matrix of adherence indicators
3. **Z**: List of matrices of the intermediate outcome
4. **Y**: Vector of the primary endpoint
5. **TRT**: Vector of a binary treatment assignment.

Note that the functions in adace are expected to be used given a user supplied dataset. See the following articles for more details on data simulation and the estimation procedure:

1. Qu, Yongming, et al. "A general framework for treatment effect estimators considering patient adherence." *Statistics in Biopharmaceutical Research* 12.1 (2020): 1-18.

2. Zhang, Ying, et al. "Statistical inference on the estimators of the adherer average causal effect." *Statistics in Biopharmaceutical Research* (2021): 1-4.


## Simulated data example

The following provides a simple example using simulated data to demonstrate the use of the package and the output it provides. Consider a clinical trial with a treatment and control. Each subject has 5 baseline covariates and subjects are followed up at 3 intermediate timepoints. At each intermediate timepoint, 3 intermediate measurements are measured for each patient. Lastly, the final endpoint occurs sometime after the 3rd follow up visit. However, at each timepoint, patients may experience an intercurrent event and drop out from the study. Therefore, the adherence of each patient is also measured at each timepoint. See the data generating model below.

The goal is to estimate the adherers average causal effect using Method A for population S++. Therefore, we generate data for X, Y, Z, TRT, and A. The data is first generated for all potential outcomes and then cleaned based on adherence status to create the observed data. We then use the function *est_S_Plus_Plus_MethodA* to get the estimate of the treatment effect and then compare it to the true treatment effect, calculated using the complete data with all potential outcomes. First we generate all potential outcome data as such:

```{r}
library(MASS)
j<- 1000
p_z <- 6 ## dimension of Z at each time point
n_t <- 4 ## number of time points
alphas <- list()
gammas <- list()
z_para <- c(-1/p_z, -1/p_z, -1/p_z, -1/p_z, -0.5/p_z,
            -0.5/p_z, -0.5/p_z, -0.5/p_z)
Z <- list()
beta = c(0.2, -0.3, -0.01, 0.02, 0.03, 0.04, rep(rep(0.02,p_z), n_t))
beta_T = -0.2
sd_z_x = 0.4
X = mvrnorm(j, mu=c(1,5,6,7,8), Sigma=diag(1,5))
TRT = rbinom(j, size = 1,  prob = 0.5)
Y_constant <- beta[1]+(X%*%beta[2:6])
Y0 <- 0
Y1 <- 0
A <- A1 <- A0 <- matrix(NA, nrow = j, ncol = n_t)
gamma <- c(1,-.1,-0.05,-0.05,-0.05,.05)
A0[,1] <- rbinom(j, size = 1, prob = 1/(1+exp(-(gamma[1] + 
                                                  (X %*% gamma[2:6])))))
A1[,1] <- rbinom(j, size = 1, prob = 1/(1+exp(-(gamma[1] + 
                                                  (X %*% gamma[2:6])))))
A[,1] <- A1[,1]*TRT + A0[,1]*(1-TRT)

for(i in 2:n_t){
  alphas[[i]] <- matrix(rep(c(2.3, -0.3, -0.01, 0.02, 0.03, 0.04, -0.4),p_z),
                        ncol=p_z)
  gammas[[i]] <- c(1, -0.1, 0.2, 0.2, 0.2, 0.2, rep(z_para[i],p_z))
  Z0 <- alphas[[i]][1,]+(X%*%alphas[[i]][2:6,]) + 
    mvrnorm(j, mu = rep(0,p_z), Sigma = diag(sd_z_x,p_z))
  Z1 <- alphas[[i]][1,]+(X%*%alphas[[i]][2:6,])+alphas[[i]][7,] +
    mvrnorm(j, mu = rep(0,p_z), Sigma = diag(sd_z_x,p_z))
  Z[[i]] <- Z1*TRT + Z0*(1-TRT)
  Y0 <- (Y0 + Z0 %*% matrix(beta[ (7 + (i-1)*p_z): (6+p_z*i)],ncol = 1) )[,1]
  Y1 <- (Y1 + Z1 %*% matrix(beta[ (7 + (i-1)*p_z): (6+p_z*i)],ncol = 1) )[,1]
  A0[,i] <- rbinom(j, size = 1,
                   prob = 1/(1+exp(-(gammas[[i]][1]+(X%*%gammas[[i]][2:6])+
                                       Z0%*%matrix(gammas[[i]][7: (7+p_z-1)], 
                                                   ncol=1))[,1])))*A0[,i-1]
  A1[,i] <- rbinom(j, size = 1,
                   prob = 1/(1+exp(-(gammas[[i]][1]+(X%*%gammas[[i]][2:6])+
                                       Z1%*%matrix(gammas[[i]][7: (7+p_z-1)], 
                                                   ncol=1))[,1])))*A1[,i-1]
  
  A[,i] <- A1[,i]*TRT + A0[,i]*(1-TRT)
}
Y0 <- Y0 + rnorm(j, mean = 0, sd = 0.3) + Y_constant
Y1 <- Y1 + + beta_T + rnorm(j, mean = 0, sd = 0.3) + Y_constant

Y <- as.vector( Y1*TRT+Y0*(1-TRT))
```

Then we create the observed dataset by setting dropouts to contain missing data.

```{r}
for(i in 2:n_t){
  Z[[i]][A[,(i-1)]==0,] <- NA    
}

Z[[1]] <- matrix(NA, nrow=nrow(Z1),ncol=ncol(Z1))

Y[A[,n_t] == 0] <- NA   
```

Note the data structore of each required argument.

```{r}
str(X)
str(Z)
str(Y)
str(TRT)
str(A)
```

Then we simply call the function and obtain our estimates. The package will provide the estimates and standard error for each arm and the treatment effect.

```{r}
fit <- est_S_Plus_Plus_MethodA(X, A, Z, Y, TRT)
fit
```

Finally, we calculate the true values and compare it to our estimated value. 

```{r}
true1 <- mean(Y1[A1[,n_t]==1 &A0[,n_t]==1])
true1
true0 <- mean(Y0[A1[,n_t]==1 &A0[,n_t]==1])
true0
true_diff <- mean(true1-true0)
true_diff
```

## Tips and Tricks

1. The estimation procedure is sensitive to adherence. Specifically, if there is near perfect or almost no adherence at any of the intermediate timepoints, the standard error cannot be estimated due to matrix inversion. However, the point estimate can still be obtained. In these situations, the standard error can be calculated using a user defined bootstrap. 

2. The estimation procedure assumes that the intermediate timepoints are independent and have a strictly diagonal covariance matrix. Simulation results have show that the coverage probablities with correlated timepoints are low for each treatment arm, but the coverage probability for the treatment effect is good. However, it should be noted that the standard error may not be trusted in this case and should be compared to bootstrap.

3. Most errors are caused by incompatible data structures of the arguments. The package will try to correct this, but please note the required data structure for each argument.

4. In Version 2 of the package, we assume that it is possible to dropout before the first intermediate timepoint. The adherence model is fitted at the first timepoint dependent only on the baseline covariates. See the above data generation process as an example. 
